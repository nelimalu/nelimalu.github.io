<html>
	<head>
		<meta charset="UTF-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <link rel="icon" href="./assets/images/logo.ico" type="image/ico">
		<title>Luka Jovanovic - School</title>

		<link rel="stylesheet" href="./styles/navbar.css">
		<link rel="stylesheet" href="./styles/notes.css">
	</head>
	<body>
		<!-- NAVBAR -->
		<div class="nav-container">
			<div class="brand">
				<span>
					<span class="brand-brackets">[</span>
					<a class="brand-link" href="index.html">jovanovic</a>
					<span class="brand-brackets">]</span>
				</span>
			</div>
			<div class="navbar">

				<div class="nav-button" onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">01</p>
					<a class="nav-link" href="index.html">// home</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">02</p>
					<a class="nav-link" href="experience.html">// experience</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">03</p>
					<a class="nav-link" href="school.html">// school</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">04</p>
					<a class="nav-link" href="contact.html">// contact</a>
				</div>
			</div>
		</div>

		<div class="main-container">
			<h1>[comp sci] / inheritance</h1>
			
			<p>
				Inheritance is done through extending a class
				<br>this can be done through the extends keyword
			</p>

<pre>
public class Student extends Person {
	// class things
}</pre>

			<h3>Subclasses and Superclasses</h3>

			<p>
				a superclass is just a regular class
				<br>a subclass "inherits" all the methods and parameters of a superclass
				<br>this means that it has all of the superclass’s methods and parameters, on top of any extra methods and attributes that can be defined specifically for that class
			</p>

			<h2>Example</h2>

<pre>
public class Person {
	String name;

	public Person(String n) {
		name = n;
	}

	public void walk() {
		System.out.println(name + " is walking!");
	}
}
</pre>

<pre>
public class Student extends Person {
	double average;

	public Student(String name, double a) {
		super(name);  // ignore this for now
		average = a;
	}

	public void study() {
		System.out.println(name + " with average " + average + " is studying");
	}
}
</pre>
			
			in this example, the an instance of the Student class will have:
		    <ul>
		    	<li>an average</li>
		    	<li>a study method</li>
		    </ul>
			but it will also have
			<ul>
		    	<li>a name</li>
		    	<li>a walk method</li>
		    </ul>

			the class inherited the name and walk method from the superclass (Person)
			<br>Since the Student class has all the attributes that Person has, the Student constructor also needs to take in all of Person’s attributes (name) on top of all of it’s own attributes (average)
			<br>this is why the constructor has two parameters `String name` and `double a`

			<br>This is how this example would work in practice

<pre>
public class Driver {
	public static void main(String[] args) {
		
		Student me = new Student("Luka", 100.0);

		System.out.println(me.name);
		System.out.println(me.average);
		me.walk();
		me.study();

		/*
		OUTPUT

		Luka
		100.0
		Luka is walking!
		Luka with average 100.0 is studying
		*/

	}
}
</pre>

			<br>the main concept to understand here is that even though the student class didn’t specifically define a walk() method, we can still run the walk method because its taken from the Person class, the class it’s inheriting from

			<h2>this keyword</h2>

			`this` is a keyword that acts as the current object the class is running as
			<br>consider the following example

<pre>
public class Person() {
	public name;

	public Person(String n) {
		name = n;
	}

	public void printThis() {
		System.out.println(this);
	}
}
</pre>

			<br>notice the `printThis()` method that prints the `this`keyword

<pre>
public class Driver {
	public static void main(String[] args) {
		Person me = new Person("Luka");

		System.out.println(me);
		System.out.println(me.printThis());

		/*
		OUTPUT

		Person@5a07e868
		Person@5a07e868
		*/
	}
}
</pre>
			
			<p>
				they have the same output!
				<br>`this` within the context of a class is the same thing as an instance variable in a different class
				<br>in this example, `this` and `me` are the same thing
				<br>`this` is commonly used in the constructor
				<br>usually, in a constructor we need to think of another name similar to the name of our attribute, in order to take it as a parameter
			</p>

<pre>
public class Person {
	String name;
	int age;

	public Person(String n, int a) {
		name = n;
		age = a;
	}
}
</pre>
			<p>
				it’s a bit unreadable when we have to make variables `n` and `a` in order to save them to `name` and `age`
				<br>a better way of doing this is by using `this`
			</p>

<pre>
public class Person {
	String name;
	int age;

	public Person(String name, int aage) {
		this.name = name;
		this.age = age;
	}
}
</pre>
			
			<p>
				these two programs do the same thing, but the latter is easier to understand for someone reading your program
				<br>[sidenote] in most other programming languages, like python and javascript, you need to use the `this` keyword in any situation where you are accessing something from your class (in python `this` is called `self`)
			    <br>this means that in java, when you don’t write `this.` explicitly, java is doing it in the background for you
			    <br>this is an important concept to understand for `super`
			</p>


			<h2>super keyword</h2>

			<p>
				`super` acts as the accessor to the superclass
				<br>if in a subclass we run a method from the superclass, we can just run the method
				<br>can bee seen in example below
			</p>

<pre>
public class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}

	public void walk() {
		System.out.println(name + " is walking!");
	}
}
</pre>

<pre>
public class Student extends Person {
	double average;

	public Student(String name, double average) {
		super(name);
		this.average = average;
	}

	public void goToClass() {
		walk();
		System.out.println(name + "is now at class!");
	}
}
</pre>
			
			<p>
				`super` is used in the constructor, but we’ll get back to that later
				<br>what’s more interesting is the `walk()` method being called in the `goToClass()` method
				<br>`walk()` is a method of the superclass
				<br>✨ **this means that we’re really just running** `super.walk()`
				<br>however, as we learned with `this`, java just adds it in on it’s own when compiling
				<br>in the constructor, we are running `super(name)`
			    <br>as we know from making a regular instance of any class, all we do is `Student("Luka", 90)`
			    <br>it’s the name of the class, treated as a method (or function), and the parameters of the constructor
			    <br>the same thing is happening here, but instead of writing the name of the superclass, we’re running `super()`
			    <br>this means that `super()` is just running the constructor of the superclass
			    <br>and this makes sense in context, because we’re passing in `name` to `super(name)` because `name` is a parameter of the `Person()` constructor, and not `Student()`
			</p>

		</div>
 
		<script src="scripts/notes.js"></script>
		<script src="scripts/navbar.js"></script>
	</body>
</html>