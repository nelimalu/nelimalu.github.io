<html>
	<head>
		<meta charset="UTF-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <link rel="icon" href="./assets/images/logo.ico" type="image/ico">
		<title>Luka Jovanovic - School</title>

		<link rel="stylesheet" href="./styles/navbar.css">
		<link rel="stylesheet" href="./styles/notes.css">
	</head>
	<body>
		<!-- NAVBAR -->
		<div class="nav-container">
			<div class="brand">
				<span>
					<span class="brand-brackets">[</span>
					<a class="brand-link" href="index.html">jovanovic</a>
					<span class="brand-brackets">]</span>
				</span>
			</div>
			<div class="navbar">

				<div class="nav-button" onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">01</p>
					<a class="nav-link" href="index.html">// home</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">02</p>
					<a class="nav-link" href="experience.html">// experience</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">03</p>
					<a class="nav-link" href="school.html">// school</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">04</p>
					<a class="nav-link" href="Subrun.html">// ISP</a>
				</div>
				<div class="nav-button"  onmouseleave="navExit(this)" onmouseenter="navEnter(this)">
					<p class="nav-number">05</p>
					<a class="nav-link" href="contact.html">// contact</a>
				</div>
			</div>
		</div>

		<div class="main-container">
			<h1>[comp sci] / inheritance</h1>
			
			<p>
				Inheritance is done through extending a class
				<br>this can be done through the extends keyword
			</p>

<pre>
public class Student extends Person {
	// class things
}</pre>

			<h3>Subclasses and Superclasses</h3>

			<p>
				a superclass is just a regular class
				<br>a subclass "inherits" all the methods and parameters of a superclass
				<br>this means that it has all of the superclass’s methods and parameters, on top of any extra methods and attributes that can be defined specifically for that class
			</p>

			<h2>Example</h2>

<pre>
public class Person {
	String name;

	public Person(String n) {
		name = n;
	}

	public void walk() {
		System.out.println(name + " is walking!");
	}
}
</pre>

<pre>
public class Student extends Person {
	double average;

	public Student(String name, double a) {
		super(name);  // ignore this for now
		average = a;
	}

	public void study() {
		System.out.println(name + " with average " + average + " is studying");
	}
}
</pre>
			
			in this example, the an instance of the Student class will have:
		    <ul>
		    	<li>an average</li>
		    	<li>a study method</li>
		    </ul>
			but it will also have
			<ul>
		    	<li>a name</li>
		    	<li>a walk method</li>
		    </ul>

			the class inherited the name and walk method from the superclass (Person)
			<br>Since the Student class has all the attributes that Person has, the Student constructor also needs to take in all of Person’s attributes (name) on top of all of it’s own attributes (average)
			<br>this is why the constructor has two parameters <c>String name</c> and <c>double a</c>

			<br>This is how this example would work in practice

<pre>
public class Driver {
	public static void main(String[] args) {
		
		Student me = new Student("Luka", 100.0);

		System.out.println(me.name);
		System.out.println(me.average);
		me.walk();
		me.study();

		/*
		OUTPUT

		Luka
		100.0
		Luka is walking!
		Luka with average 100.0 is studying
		*/

	}
}
</pre>

			<br>the main concept to understand here is that even though the student class didn’t specifically define a walk() method, we can still run the walk method because its taken from the Person class, the class it’s inheriting from

			<h2>this keyword</h2>

			<c>this</c> is a keyword that acts as the current object the class is running as
			<br>consider the following example

<pre>
public class Person() {
	public name;

	public Person(String n) {
		name = n;
	}

	public void printThis() {
		System.out.println(this);
	}
}
</pre>

			<br>notice the <c>printThis()</c> method that prints the <c>this</c>keyword

<pre>
public class Driver {
	public static void main(String[] args) {
		Person me = new Person("Luka");

		System.out.println(me);
		System.out.println(me.printThis());

		/*
		OUTPUT

		Person@5a07e868
		Person@5a07e868
		*/
	}
}
</pre>
			
			<p>
				they have the same output!
				<br><c>this</c> within the context of a class is the same thing as an instance variable in a different class
				<br>in this example, <c>this</c> and <c>me</c> are the same thing
				<br><c>this</c> is commonly used in the constructor
				<br>usually, in a constructor we need to think of another name similar to the name of our attribute, in order to take it as a parameter
			</p>

<pre>
public class Person {
	String name;
	int age;

	public Person(String n, int a) {
		name = n;
		age = a;
	}
}
</pre>
			<p>
				it’s a bit unreadable when we have to make variables <c>n</c> and <c>a</c> in order to save them to <c>name</c> and <c>age</c>
				<br>a better way of doing this is by using <c>this</c>
			</p>

<pre>
public class Person {
	String name;
	int age;

	public Person(String name, int aage) {
		this.name = name;
		this.age = age;
	}
}
</pre>
			
			<p>
				these two programs do the same thing, but the latter is easier to understand for someone reading your program
				<br>[sidenote] in most other programming languages, like python and javascript, you need to use the <c>this</c> keyword in any situation where you are accessing something from your class (in python <c>this</c> is called <c>self</c>)
			    <br>this means that in java, when you don’t write <c>this.</c> explicitly, java is doing it in the background for you
			    <br>this is an important concept to understand for <c>super</c>
			</p>


			<h2>super keyword</h2>

			<p>
				<c>super</c> acts as the accessor to the superclass
				<br>if in a subclass we run a method from the superclass, we can just run the method
				<br>can bee seen in example below
			</p>

<pre>
public class Person {
	String name;

	public Person(String name) {
		this.name = name;
	}

	public void walk() {
		System.out.println(name + " is walking!");
	}
}
</pre>

<pre>
public class Student extends Person {
	double average;

	public Student(String name, double average) {
		super(name);
		this.average = average;
	}

	public void goToClass() {
		walk();
		System.out.println(name + "is now at class!");
	}
}
</pre>
			
			<p>
				<c>super</c> is used in the constructor, but we’ll get back to that later
				<br>what’s more interesting is the <c>walk()</c> method being called in the <c>goToClass()</c> method
				<br><c>walk()</c> is a method of the superclass
				<br>✨ **this means that we’re really just running** <c>super.walk()</c>
				<br>however, as we learned with <c>this</c>, java just adds it in on it’s own when compiling
				<br>in the constructor, we are running <c>super(name)</c>
			    <br>as we know from making a regular instance of any class, all we do is <c>Student("Luka", 90)</c>
			    <br>it’s the name of the class, treated as a method (or function), and the parameters of the constructor
			    <br>the same thing is happening here, but instead of writing the name of the superclass, we’re running <c>super()</c>
			    <br>this means that <c>super()</c> is just running the constructor of the superclass
			    <br>and this makes sense in context, because we’re passing in <c>name</c> to <c>super(name)</c> because <c>name</c> is a parameter of the <c>Person()</c> constructor, and not <c>Student()</c>
			</p>

			<h2>Polymorphism</h2>

polymorphism is the ability for an object to take on many forms
<br>in java, this often means that a subclass can be treated as a superclass
<br>let’s look at an example

<pre>
public class Animal {
	public void makeSound() {
		System.out.println("generic animal sound");
	}
}</pre>

<pre>
public class Cat extends Animal {
	public void makeSound() {
		System.out.println("meow");
	}
}</pre>

<pre>
public class Dog extends Animal {
	public void makeSound() {
		System.out.println("bark");
	}
}</pre>

here we have three classes, <c>Animal</c>, <c>Cat</c>, and <c>Dog</c>
<br><c>Cat</c> and <c>Dog</c> both <c>extend</c> <c>Animal</c>
<br>this means that they have all of <c>Animal</c>’s methods and parameters
<br>notice that <c>Cat</c> and <c>Dog</c> both have their own <c>makeSound()</c> methods
<br>let’s look at what happens when we treat a <c>Cat</c> and <c>Dog</c> as an <c>Animal</c>

<pre>
public class Driver {
	public static void main(String[] args) {

		Animal[] animals = new Animal[2];
		animals[0] = new Cat();
		animals[1] = new Dog();

		for (Animal a : animals) {
			a.makeSound();
		}

		/*
		OUTPUT

		meow
		bark
		*/

	}
}</pre>

in this example, we create an array of <c>Animal</c>s, and add a <c>Cat</c> and a <c>Dog</c> to it
<br>then we loop through the array and run the <c>makeSound()</c> method of each <c>Animal</c>
<br>even though <c>Cat</c> and <c>Dog</c> both have their own <c>makeSound()</c> method, they are still able to run the <c>makeSound()</c> method of their superclass (<c>Animal</c>)
<br>this is because they still have the method, they just overrode it with their own implementation
<br>the important thing to understand here is that we were able to treat a <c>Cat</c> and <c>Dog</c> as an <c>Animal</c>, because they extend it

		<h2>Interfaces</h2>

an interface is like a class, but it only has method signatures
<br>this means that an interface is a list of methods that a class that implements the interface *must* have
<br>interfaces are useful because they allow you to write code that depends on certain methods existing, without worrying about the implementation
<br>this is because with interfaces, you only care that a certain method does exist, you don’t care how it does what it does
<br>this is useful because it allows you to build your code in a modular way
<br>for example, if you’re building a game, and you want to have different Player classes (like <c>HumanPlayer</c>, <c>ComputerPlayer</c>, <c>NetworkPlayer</c>), you can write code that only refers to the <c>Player</c> interface, and not the specific implementation
<br>this means that you can add new Player classes easily, without having to rewrite any of the code that uses the <c>Player</c> interface
<br>here’s an example of an interface:

<pre>
public interface Shape {
    public double getArea();
    public double getPerimeter();
}</pre>

this is an interface for a <c>Shape</c>
<br>any class that implements this interface *must* have a <c>getArea()</c> and a <c>getPerimeter()</c> method
<br>here’s an example of a class that implements the <c>Shape</c> interface

<pre>
public class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double w, double h) {
        width = w;
        height = h;
    }

    public double getArea() {
        return width * height;
    }

    public double getPerimeter() {
        return 2 * (width + height);
    }
}</pre>

this is a <c>Rectangle</c> class that implements the <c>Shape</c> interface
<br>notice that the class has a <c>getArea()</c> and a <c>getPerimeter()</c> method, just like the interface requires
<br>this means that any code that uses the <c>Shape</c> interface can also use the <c>Rectangle</c> class
<br>here’s another example of a class that implements the <c>Shape</c> interface

<pre>
public class Circle implements Shape {
    private double radius;

    public Circle(double r) {
        radius = r;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }

    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}</pre>

this is a <c>Circle</c> class that implements the <c>Shape</c> interface
<br>just like the <c>Rectangle</c> class, it has a <c>getArea()</c> and a <c>getPerimeter()</c> method
<br>this means that any code that uses the <c>Shape</c> interface can also use the <c>Circle</c> class
<br>here’s an example of code that uses the <c>Shape</c> interface

<pre>
public static void main(String[] args) {
    Shape[] shapes = new Shape[2];
    shapes[0] = new Rectangle(5, 10);
    shapes[1] = new Circle(3);

    for (Shape s : shapes) {
        System.out.println("Area: " + s.getArea() + ", Perimeter: " + s.getPerimeter());
    }
}</pre>

this code creates an array of <c>Shape</c> objects, and adds a <c>Rectangle</c> and a <c>Circle</c> to it
<br>then it loops through the array, and prints out the area and perimeter of each shape
<br>notice that the code doesn’t care *how* the area and perimeter are calculated, it only cares *that* the methods exist
<br>this means that if you add a new class that implements the <c>Shape</c> interface, the code will still work, without having to change it

		</div>
 
		<script src="scripts/notes.js"></script>
		<script src="scripts/navbar.js"></script>
	</body>
</html>